This is a simple live code editor built with React. It lets users write HTML, CSS, and JavaScript in separate editors and instantly see the output below. The code is stored in the browser using local storage, so it stays even after refreshing the page. The output is shown in real-time using an iframe.

I built the `Editor.jsx` component as a reusable code editor using React and CodeMirror, kind of like what you see on CodePen or JSFiddle. I used CodeMirror because it gives a clean, styled editor with syntax highlighting, line numbers, and themes. I imported its core CSS, a dark "material" theme, and language modes for HTML, CSS, and JS so it can highlight code properly. I’m using the `Controlled` editor from `react-codemirror2`, renamed as `CodeMirror`, which means I control its content through React props and state. The component takes in props like `language`, `displayName`, `value`, and `onChange` — so it knows what type of code it’s editing and can update the content as the user types. I render a title bar and the editor itself, and inside the editor I pass some options like enabling line numbers, using the dark theme, and setting the correct language mode. Even though I imported `useState`, I’m not using it yet, but it’s there in case I want to add extra features later. This component is the core input area for my live code editor app, and I made it flexible so I can reuse it for HTML, CSS, and JavaScript just by changing the props.

useLocalStorage.js Component:
This is a custom React hook I made called useLocalStorage, and it's used to store and manage data using both React’s useState and the browser’s localStorage. Normally, when we use useState, the data stays only while the page is open. But if we refresh the page, that data is gone. So to make the data stay even after reloading, I use localStorage, which is a feature built into every browser that lets you store key-value pairs permanently. Inside the hook, I first add a prefix to the key name so it doesn’t clash with anything else in localStorage. Then, I check if something is already saved in localStorage using localStorage.getItem. If it exists, I use JSON.parse to convert it from a saved string back into the original data (because localStorage only stores strings). If it doesn’t exist, I use the initial value. Then, I use useEffect to watch for any changes to the value, and whenever it changes, I use localStorage.setItem to save it. I use JSON.stringify here to convert the value into a string before saving it, because again, localStorage can’t store real objects — only strings. Finally, I return the value and the function to update it, just like useState, so I can use this hook the same way I’d use useState, but with the added benefit of persistent data. This hook helps me keep the user’s HTML, CSS, and JavaScript code saved in my code editor app even if they close or refresh the page.

App.jsx file:
This is the main part of my React app that builds a simple live code editor like CodePen. I’m using three separate editors for HTML, CSS, and JavaScript by reusing a custom Editor component. For each of these editors, I store the user’s input using a custom hook I made called useLocalStorage, which lets me save the code in the browser even if the user refreshes or comes back later. I call this hook three times — once for each language — to manage the saved values. Then I use a fourth piece of state called srcDoc which contains the full HTML document that gets rendered in a live preview below. Inside a useEffect, I update this srcDoc value every time the user changes the HTML, CSS, or JavaScript. I use setTimeout with a small delay (250ms) to avoid updating the preview too frequently while typing. In the return statement, I render all three editors at the top inside a div with class top-pane, and below that I render an <iframe> which shows the result in real-time by setting its srcDoc to the combined code. The iframe acts like a mini browser inside the page. This way, the user can write code and instantly see the output below. Technologies I used include React functional components, custom hooks, CodeMirror for the editor UI, and localStorage to keep user code saved between sessions.
